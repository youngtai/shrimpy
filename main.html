<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Shrimpy</title>
  <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
  <style type="text/css">
      body {
          margin: 0;
      }
  </style>
</head>
<body>
<script type="text/javascript">

const game = new Phaser.Game({
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  physics: {
    default: 'arcade',
    arcade: {
      debug: false
    }
  },
  scene: {
    preload: preload,
    create: create,
    update: update
  }
});

let player;
let fishGroup;
let cursors;
let keySpace;
let playerVelocity;

let playerTailKickReady = true;

const TAIL_KICK_MULTIPLIER = 5; // Multiply current player velocity by this when tail is kicked
const TAIL_KICK_COOLDOWN_TIME = 10000; // 10 seconds
const DEFAULT_PLAYER_DRAG = 50;
const FISH_WAKE_DELAY = 2000; // Time it takes for a fish to wake up after being bumped by player

function preload() {
  this.load.image('shrimp', 'assets/shrimp.png');
  this.load.image('fish', 'assets/fish-2.png');
  this.load.image('background', 'assets/background-2.png');
}

function create() {
  this.add.image(400, 300, 'background');

  cursors = this.input.keyboard.createCursorKeys();
  keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

  player = this.physics.add.image(400, 300, 'shrimp');
  player.setCollideWorldBounds(true);
  player.setDrag(DEFAULT_PLAYER_DRAG);
  player.setBounce(0.3);

  fishGroup = this.physics.add.group({
    key: 'fish',
    repeat: 19
    // setXY: {x: 100, y: 100, stepX: 75, stepY: 50}
  });
  fishGroup.children.iterate(child => {
    child.setPosition(randomInt(0, 800), randomInt(0, 600));
    child.setCollideWorldBounds(true);
    child.setBounce(0.35);
    // child.setDrag(50);
    child['awake'] = false;
    child.setVelocityX(randomInt(-10, 10));
    child.setVelocityY(randomInt(-10, 10));
  });

  this.physics.add.collider(player, fishGroup, handlePlayerFishCollision, null, this);
  this.physics.add.collider(fishGroup, fishGroup);
}

const playerVelocityBelowThreshold = () => Math.abs(player.body.velocity.x) <= 100 && Math.abs(player.body.velocity.y) <= 100;

function update() {
  // fishGroup.children.iterate(child => this.physics.accelerateToObject(child, player, 200, 120, 120));
  fishGroup.children.iterate(child => {
    if (child.awake) {
      this.physics.moveToObject(child, player, 110);
    } else {
      // Fish randomly drifts
      // child.setVelocityX(randomInt(-10, 10));
      // child.setVelocityY(randomInt(-10, 10));
    }
  });

  // Left/Right movement
  if (cursors.left.isDown) {
    if (playerVelocityBelowThreshold()) {
      player.setVelocity(-100, 0);
    } else {
      if (Math.abs(player.body.velocity.y) > 100) {
        player.setVelocity(Math.abs(player.body.velocity.y) * -1, 0);
      } else if (Math.abs(player.body.velocity.x) > 100) {
        player.setVelocity(Math.abs(player.body.velocity.x) * -1, 0);
      }
    }
    // player.setRotation(0);
  } else if (cursors.right.isDown) {
    if (playerVelocityBelowThreshold()) {
      player.setVelocity(100, 0);
    } else {
      if (Math.abs(player.body.velocity.y) > 100) {
        player.setVelocity(Math.abs(player.body.velocity.y), 0);
      } else if (Math.abs(player.body.velocity.x) > 100) {
        player.setVelocity(Math.abs(player.body.velocity.x), 0);
      }
    }
    // player.setRotation(0);
  } else {
    // player.setVelocityX(randomInt(-5, 5));
  }

  // Up/Down movement
  if (cursors.up.isDown) {
    if (playerVelocityBelowThreshold()) {
      player.setVelocity(0, -100);
    } else {
      if (Math.abs(player.body.velocity.y) > 100) {
        player.setVelocity(0, Math.abs(player.body.velocity.y) * -1);
      } else if (Math.abs(player.body.velocity.x) > 100) {
        player.setVelocity(0, Math.abs(player.body.velocity.x) * -1);
      }
    }
    // player.setRotation(90);
  } else if (cursors.down.isDown) {
    if (playerVelocityBelowThreshold()) {
      player.setVelocity(0, 100);
    } else {
      if (Math.abs(player.body.velocity.y) > 100) {
        player.setVelocity(0, Math.abs(player.body.velocity.y));
      } else if (Math.abs(player.body.velocity.x) > 100) {
        player.setVelocity(0, Math.abs(player.body.velocity.x));
      }
    }
    // player.setRotation(-90);
  } else {
    // player.setVelocityY(randomInt(-5, 5));
  }

  if (this.input.keyboard.checkDown(keySpace, TAIL_KICK_COOLDOWN_TIME) && playerTailKickReady) {
    player.setVelocity(player.body.velocity.x * TAIL_KICK_MULTIPLIER, player.body.velocity.y * TAIL_KICK_MULTIPLIER);
    playerTailKickReady = false;
    this.time.addEvent({
      delay: TAIL_KICK_COOLDOWN_TIME,
      callback: () => {
        playerTailKickReady = true;
      }
    });
  }
}

function handlePlayerFishCollision(player, fish) {
  if (fish.awake) {
    this.physics.pause();
    player.setTint(0xff0000);
    gameOver = true;
  } else {
    this.time.addEvent({
      delay: FISH_WAKE_DELAY,
      callback: () => fish.awake = true
    });
  }
}

const randomInt = (min, max) => {return Math.floor(Math.random() * (max - min)) + min};

</script>
</body>
</html>